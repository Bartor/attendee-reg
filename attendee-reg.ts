type ID = number;

const SCALE = 100;

export enum PreferenceType {
  ROOM_SIZE,
  ROOM_NUMBER,
  STAY_WITH,
}

type Preference =
  | { type: PreferenceType.ROOM_NUMBER; payload: ID }
  | { type: PreferenceType.STAY_WITH; payload: ID }
  | { type: PreferenceType.ROOM_SIZE; payload: number };

export type WeightedPreference = Preference & { weight: number };

export type Room = {
  id: ID;
  holds: number;
};

export type RoomWithAttendees = Room & { assigned: Set<ID> };

export type Attendee = {
  id: ID;
  preferences: WeightedPreference[];
};

/**
 * Decide if a given Room fits Attendee's given Preference
 * @param room Room to test
 * @param preference Preference to test
 * @returns True if it does, false otherwise
 */
function roomFitsPreference(
  room: RoomWithAttendees,
  { type, payload }: Preference
) {
  if (room.assigned?.size === room.holds) return false;

  switch (type) {
    case PreferenceType.ROOM_NUMBER:
      return room.id === payload;
    case PreferenceType.ROOM_SIZE:
      return room.holds === payload;
    case PreferenceType.STAY_WITH:
      return room.assigned.has(payload);
  }
}

/**
 * Returns a map of preference scores (sum of preference weights) for each room for a given set of preferences
 * @param rooms Rooms to consider
 * @param preferences Preferences to consider
 * @returns A preference map and a sum to allow for normalization
 */
function calculatePreferenceScores(
  rooms: RoomWithAttendees[],
  preferences: WeightedPreference[]
): {
  preferenceMap: Record<ID, number>;
  preferenceSum: number;
} {
  const preferenceMap = rooms.reduce<Record<ID, number>>((map, room) => {
    map[room.id] = preferences.reduce(
      (sum, preference) =>
        sum + (roomFitsPreference(room, preference) ? preference.weight : 0),
      0
    );
    return map;
  }, {});

  const preferenceSum = Object.values(preferenceMap).reduce(
    (sum, value) => sum + value,
    0
  );

  return { preferenceMap, preferenceSum };
}

function weightedRandom(weights: number[]) {
  const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);

  let random = Math.random() * totalWeight;

  for (let i = 0; i < weights.length; i++) {
    if (random < weights[i]) {
      return i;
    }

    random -= weights[i];
  }

  return -1;
}

/**
 * Selects a random Attendee based on a weights generated by summing Attendees' preferences scores
 * @param attendees List of all Attendees
 * @param rooms List of all Rooms
 * @returns A random Attendee from the list
 */
function selectRandomAttendee(
  attendees: Attendee[],
  rooms: RoomWithAttendees[]
): Attendee {
  const weights = attendees.map((attendee) => {
    const { preferenceSum } = calculatePreferenceScores(
      rooms,
      attendee.preferences
    );

    return preferenceSum;
  });

  const index = weightedRandom(weights);

  return attendees[index];
}

/**
 * Generates room assignments
 * @param attendees List of all Attendees
 * @param rooms List of all Rooms
 * @param userPreferenceCoefficient How much of user's preference to consider in room searching calculation
 * @returns A list of Rooms with assigned Attendees
 */
export function assignRooms(
  attendees: Attendee[],
  rooms: Room[],
  userPreferenceCoefficient: number
): RoomWithAttendees[] {
  const attendeesToAssignMap = new Map<ID, Attendee>();
  attendees.forEach((attendee) =>
    attendeesToAssignMap.set(attendee.id, attendee)
  );

  const roomsWithAttendees = rooms.map<RoomWithAttendees>((room) => ({
    ...room,
    assigned: new Set(),
  }));

  while (attendeesToAssignMap.size > 0) {
    const attendeesToAssign = Array.from(attendeesToAssignMap.values());

    // Select a random Attendee based on their weighted probability
    const selectedAttendee = selectRandomAttendee(
      attendeesToAssign,
      roomsWithAttendees
    );
    const {
      preferenceMap: selectedAttendeePreferenceMap,
      preferenceSum: selectedAttendeePreferenceSum,
    } = calculatePreferenceScores(
      roomsWithAttendees,
      selectedAttendee.preferences
    );

    // See how assigning selected Attendee to a given Room would impact the preference
    // scores of all the Rooms
    const roomsAfterAssignmentScores = roomsWithAttendees.reduce<
      Record<ID, number>
    >((map, room, index) => {
      // For full rooms, it's a no-go
      if (room.assigned.size === room.holds) {
        map[room.id] = 0;
      } else {
        // Create a new list of Rooms, where the currently considered room has the
        // currently considered Attendee assigned
        const currentRoomsState: RoomWithAttendees[] = [
          ...roomsWithAttendees.slice(0, index),
          {
            ...room,
            assigned: new Set([...room.assigned, selectedAttendee.id]),
          },
          ...roomsWithAttendees.slice(index + 1),
        ];

        // Sum the scores of all the Rooms with the new list
        const scoreSum = attendeesToAssign.reduce(
          (sum, attendee) =>
            sum +
            calculatePreferenceScores(currentRoomsState, attendee.preferences)
              .preferenceSum,
          0
        );

        map[room.id] = scoreSum;
      }

      return map;
    }, {});

    // Create a sum for normalization purposes
    const roomsAfterAssignmentScoreSum = Object.values(
      roomsAfterAssignmentScores
    ).reduce((sum, score) => sum + score, 0);

    // Select a best choice Room ID
    const bestChoiceRoomId = Object.entries(roomsAfterAssignmentScores).sort(
      ([idA, scoreA], [idB, scoreB]) => {
        const normalizedUserPreferenceA =
          selectedAttendeePreferenceMap[Number(idA)] /
          selectedAttendeePreferenceSum;
        const adjustedUserPreferenceA =
          normalizedUserPreferenceA * userPreferenceCoefficient;

        const normalizedUserPreferenceB =
          selectedAttendeePreferenceMap[Number(idB)] /
          selectedAttendeePreferenceSum;
        const adjustedUserPreferenceB =
          normalizedUserPreferenceB * userPreferenceCoefficient;

        const normalizedRoomScoreA = scoreA / roomsAfterAssignmentScoreSum;
        const adjustedRoomScoreA =
          normalizedRoomScoreA * (1 - userPreferenceCoefficient);

        const normalizedRoomScoreB = scoreB / roomsAfterAssignmentScoreSum;
        const adjustedRoomScoreB =
          normalizedRoomScoreB * (1 - userPreferenceCoefficient);

        return (
          adjustedRoomScoreB +
          adjustedUserPreferenceB -
          (adjustedRoomScoreA + adjustedUserPreferenceA)
        );
      }
    )[0][0];

    // Find this Room, assign Attendee to it and remove the Attendee from the waiting list
    const roomToChoose = roomsWithAttendees.find(
      ({ id }) => id === Number(bestChoiceRoomId)
    );

    roomToChoose?.assigned.add(selectedAttendee.id);
    attendeesToAssignMap.delete(selectedAttendee.id);
  }

  return roomsWithAttendees;
}
